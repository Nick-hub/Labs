#include<locale.h> // заголовочгый файл для функции setlocale()
#include<iomanip> // заголовочный файл для cout, « и много чего еще
#include<bitset>
#include<iostream>
using namespace std;
/*
Динамическая память(C++)
Определения и синтаксис
Класс - шаблонное описание, по которому создаются объекты.В некотором роде аналогичен типу данных - является всего лишь описанием, по которому могут быть созданы многочисленные экземпляры.
class car // игровое транспортное средство
{
    double max_speed = 120; // свойство, скорость, проинициализирована
    double fuel_consumption; // свойство, потребление топлива
    double current_speed; // свойство, скорость
    char regnumber[6] = { 0 }; // свойство, госномер
    unsigned char capacity; // свойство, число пасажиров
    accelerate(double v); // метод, увеличить скорость
    get_coordinate(/*... *//*); // метод, получить текущее положение
    /*
    change_color(/*...*//*); // метод, сменить текстуру
}
/*
Объект - экземпляр класса.В каком - то роде аналогичен переменной : можно создать переменную M типа N, и объект K класса L.
// где-то в коде:
car car_object1; // объект в стековой памяти (локальный)
car* car_object2; // указатель на объект в динамической памяти
car_object2 = new car; // создание самого объекта в динамической памяти
Методы - функции в составе класса(объявленные внутри класса).
Свойства - переменные в составе класса(объявленные внутри класса).
Чтобы воспользоваться свойствами и методами конструктора, используются операторы доступа “.” если объект локальный и “->” если объект представлен указателем :
// где-то в коде:
car_object1.max_speed = 150; // для локального объекта
car_object1.accelerate(150); // для локального объекта

car_object2->max_speed = 150; // для объекта, представленного указателем
car_object2->accelerate(150); // для объекта, представленного указателем

Чтобы изнутри конструктора сослаться на объект, который его представляет, используется указатель this.
Конструктор - метод класса, автоматически подставляемый компилятором в код без участия программиста в момент создания объекта класса.Конструктор необходим в случае
если при создании объекта нужно выполнять действия по инициализации, установлению сетевого соединения, открытию файлов, выделению динамической памяти и т.д.
если при создании объекта нужно скопировать его свойства на основе другого объекта.
Конструктор всегда по правилам C++ имеет то же имя, что и класс, и не возвращает параметров :
class car // игровое транспортное средство
{
    car() {} // конструктор по умолчанию
    car(car another_car) // копирующий конструктор
    {
        this->max_speed = another_car.max_speed;
        this->fuel_consumption = another_car.fuel_consumption;
        this->current_speed = another_car.current_speed;
        this->capacity = another_car.capacity;
    }
}
Если при уничтожении объекта нужно освобождать некоторые общие ресурсы и выполнять другие обязательные действия, объявляется метод - деструктор.Деструктор подставляется компилятором автоматически в код, когда прекращается срок жизни объекта(в конце функции, где был объявлен объект, либо в конце работы приложения).Деструктор не получает и возвращает параметров.Имя деструктора всегда равно имени класса с тильдой в начале :
class car // игровое транспортное средство
{
    ~car() // деструктор
    {
        save_to_file();
        close_file();
        delete[] block_of_memory;
        connection.close();
    }
}
Методы + свойства = поля класса.
Инкапсуляция, наследование и полиморфизм - три основные идеи(парадигмы) ООП.
Инкапсуляция - фактически, объединение данных и методов, объединённых общим смыслом, в одну конструкцию(класс), а также защита данных и механизмов конструкции от стороннего вмешательства.
Наследование - создание дочернего класса от некоего родительского и заимствование в дочернем свойств и методов родительского.Позволяет быстро обновлять / изменять кодовую базу : изменения в родительском классе автоматически применяются ко всем дочерним.Один класс можно наследовать от нескольких родительских.

Полиморфизм - простыми словами : экземпляры одного класса ведут себя по - разному.
Для ограничения доступа в стороннем коде к полям класса применяются спецификаторы доступа public, protected и private (если не применять ни один из спецификаторов, по умолчанию работает private) :
    class car // игровое транспортное средство
{
private: // всё, что ниже до следующего спецификатора, будет private
    double max_speed = 120; // свойство, недоступное извне
    double fuel_consumption; // свойство, недоступное извне
    double current_speed; // свойство, недоступное извне
    char regnumber[6] = { 0 }; // свойство, недоступное извне
    unsigned char capacity; // свойство, недоступное извне
    get_coordinate(/*... *//*); // метод, недоступный извне
/*
public:
    car(/*???*//*); // должен быть в public
    /*
    change_color(/*...*//*); // метод, доступный извне
    /*
    accelerate(double v); // метод, доступный извне
}
/*
После таких изменений в классе изменится поведение объекта :
// где-то в коде
car_object1.max_speed = 150; // !!!ВЫЗОВЕТ ОШИБКУ КОМПИЛЯЦИИ
car_object1.change_color(“cherry”);
Пример кода модуля с классом :
#include<iostream>
#include<string>
class car // игровое транспортное средство
{
private: // всё, что ниже до следующего спецификатора, будет private
    double max_speed = 120; // свойство, недоступное извне
    double fuel_consumption; // свойство, недоступное извне
    double current_speed; // свойство, недоступное извне
    char regnumber[6] = { 0 }; // свойство, недоступное извне
    unsigned char capacity; // свойство, недоступное извне
    double get_coordinate() { return 0.0; } // метод, недоступный извне
    std::string color = “green”;
public:
    car() {}
    void change_color(std::string pColor); // метод, определённый СНАРУЖИ
    bool accelerate(double v) // метод, определённый ВНУТРИ класса
    {
        if (v <= this->max_speed)
        {
            this->current_speed = v;
            return true;
        }
        else
            return false;
    }
};
void car::change_color(std::string pColor) // метод, определённый СНАРУЖИ
{
    this->color = pColor;
}

int main(void)
{
    // настройка локализации и кодировки

    car car_object1; // объект в стековой памяти (локальный)
    car* car_object2; // указатель на объект в динамической памяти
    car_object2 = new car; // создание самого объекта в динамической памяти

    car_object1.max_speed = 150; // !!!ВЫЗОВЕТ ОШИБКУ КОМПИЛЯЦИИ
    car_object1.change_color(“cherry”);
    // обращаться к остальным свойствам и вызывать прочие методы

    std::system(“pause”);
}

Применение
Пример 1. При электронной обработке документа(скажем, PDF или Word) удобно объединить в класс все функции по действиям с документом, а также все связанные с ним переменные.
class Document {
    Document(); // пустой конструктор
    Document(string filename); // конструктор, который при создании объекта также открывает файл
    insert_text(/*...*//*); // вставить фрагмент в документ
    /*
    insert_image(/*...*//*); // вставить изображение в  документ
    /*
    save(); // сохранить фрагмент в файл
    string contents; // строка, куда считывается  содержимое файла
    time_t creation_time; // время создания файла
}

*/

class firma {
private:// доступ ограничен

  string name = " Ситилинк ";
  string name2 = " Самсунг ";
    
public: // общий доступ
   firma() { std::cout << "Расчет прибыли магазинов " << this << std::endl; }// пустой конструктор
   firma(firma const& Predpriyatie {} // копирующий конструктор

    double dohod;
    double komisiya;
    string name;
    double pribul()
    {
        return dohod - komisiya;
    }
    double nalog()
    {
        return (dohod / 18) + (komisiya /18)
    }
    double zarplatu()
    {
        return (dohod/100) + (komisiya /100)+ (nalog/100)
    }
    double ubitok()
    {
        return nalog + zarplatu + komisiya;
    }
    ~firma() { cout << "Подсчет завершен." << this << std::endl; } // Вызов деструктора
};


int main()
{
    setlocale(LC_ALL, "Russian");
   firma citylink;
    citylink.dohod = 15;
    citylink.komisiya = 2;
    cout << "Прибыль фирмы Citylink без убытка:= ";
    cout << citylink.pribul();
    cout << "Чистая прибыль фирмы Citylink:= ";
    cout << citylink.pribul() - citylink.ubitok();
    firma samsung;
    samsung.dohod = 21;
    samsung.komisiya = 1;
    cout << "Прибыль фирмы Samsung без убытка:= ";
    cout << samsung.pribul();
    cout << "Чистая прибыль фирмы Samsung:= ";
    cout << samsung.pribul() - samsung.ubitok();

    system("pause");
    return 0;
}